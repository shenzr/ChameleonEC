#include "BUTTERFLY64Util.hh"

BUTTERFLYUtil::BUTTERFLYUtil(Config* conf) {
    // BUTTERFLY (6, 4), n=k+2, each block divided into 2^(k-1) sub-blocks
    _ecN = conf->_ecN;
    _ecK = conf->_ecK;
    _alpha = 1 << (_ecK-1); // 8
    
    _encMat = (int*)calloc(_ecK * _alpha * _ecN * _alpha, sizeof(int));
    generate_encoding_matrix();
}

void BUTTERFLYUtil::generate_encoding_matrix() {
    // data
    for (int i = 0; i < _ecK * _alpha; i++) {
        _encMat[i * _ecK * _alpha + i] = 1;
    }

    // parity H
    int temp = 0;
    for (int i = _ecK * _alpha; i < _ecK * _alpha + _alpha; i++) {
        for (int j = 0; j < _ecK; j++) {
            if (i % _alpha == temp) {
                _encMat[i * _ecK * _alpha + _alpha * j + temp] = 1;
            }
        }
        temp++;
    }

    // parity B
    int B[8 * 32] = {
        0,0,0,0,0,0,0,1, 0,0,0,1,0,0,0,0, 0,1,0,0,0,0,0,0, 1,0,0,0,0,0,0,0, // d7+c3+b1+a0
        0,0,0,0,0,0,1,0, 0,0,1,0,0,0,0,0, 1,0,0,0,0,0,0,0, 1,1,0,0,0,0,0,0, 
        0,0,0,0,0,1,0,0, 0,1,0,0,0,0,0,0, 0,1,0,1,0,0,0,0, 0,1,1,1,0,0,0,0,
        0,0,0,0,1,0,0,0, 1,0,0,0,0,0,0,0, 1,0,1,0,0,0,0,0, 1,0,0,1,0,0,0,0, 
        0,0,0,1,0,0,0,0, 0,0,0,1,0,0,0,1, 0,0,0,1,0,1,0,1, 0,0,0,1,1,0,0,1, 
        0,0,1,0,0,0,0,0, 0,0,1,0,0,0,1,0, 0,0,1,0,1,0,1,0, 0,0,1,0,1,1,1,0,
        0,1,0,0,0,0,0,0, 0,1,0,0,0,1,0,0, 0,1,0,0,0,0,0,1, 0,1,0,0,0,0,1,1, 
        1,0,0,0,0,0,0,0, 1,0,0,0,1,0,0,0, 1,0,0,0,0,0,1,0, 1,0,0,0,0,0,0,1}; // d0+c0+b0+a0+c4+b6+a7
    memcpy(_encMat + 40 * 32, B, 8 * 32 * sizeof(int));
}


int* BUTTERFLYUtil::getCoefficient(int idx) { //idx responds to failed block id in the stripe
    int* coef = (int*)calloc(_ecN-1, sizeof(int));
    
    if(idx < _ecK-1) { // case(1) in butterfly code paper, D1 ~ D[k-1] lost
        vector<int> subIndexOff;
        int idj = _ecK-1-idx;
        for(int i=0; i<_alpha; ++i) {
            int tmp = i/(1<<(idj-1));
            tmp = tmp%4;
            if(!tmp || tmp==3) {
                subIndexOff.push_back(i);
            }
        }
        assert(subIndexOff.size() == _alpha/2);
        int coefficient = 0;
        for(int i=0; i<subIndexOff.size(); ++i) {
            coefficient |= 1 << (_alpha-1-subIndexOff[i]+(_ecK-1-i)*_alpha);
        }
        for(int i=0; i<_ecN-1; ++i) coef[i] = coefficient;
        
    } else if(idx == _ecK-1) { // case(2) in butterfly code paper, D0 lost
        int even = 0x80200802;  // 10000000 00100000 00001000 00000010
        int odd = 0x40100401;   // 01000000 00010000 00000100 00000001
        for(int i=0; i<_ecN-2; ++i) coef[i] = even;
        coef[_ecN-2] = odd;  

    } else if(idx == _ecN-2) { // case(3) in butterfly code paper, H lost
        int bottomHalf = 0x08040201; // 00001000 00000100 00000010 00000001
        for(int i=0; i<_ecN-1; ++i) coef[i] = bottomHalf;
 
    } else if(idx == _ecN-1) { // case(4) in butterfly code paper, B lost
        int topHalf = 0x80402010;    // 10000000 01000000 00100000 00010000
        int bottomHalf = 0x08040201; // 00001000 00000100 00000010 00000001
        coef[0] = topHalf;
        coef[4] = bottomHalf;
        coef[1] = 0x11224488; // 00010001 00100010 01000100 10001000
        coef[2] = 0x152A4182; // 00010101 00101010 01000001 10000010
        coef[3] = 0x192E4381; // 00011001 00101110 01000011 10000001
    }

    return coef;
}

void BUTTERFLYUtil::generate_decoding_matrix(int decMat[6][160]) { //idx responds to failed block id in the stripe
    // idx = 0, Dk3 lost
    int a[160] = {  1,0,0,0, 1,0,0,0, 1,0,0,0, 1,0,0,0, 0,0,0,0,
                    0,1,0,0, 0,1,0,0, 0,1,0,0, 0,1,0,0, 0,0,0,0,
                    0,0,1,0, 0,0,1,0, 0,0,1,0, 0,0,1,0, 0,0,0,0,
                    0,0,0,1, 0,0,0,1, 0,0,0,1, 0,0,0,1, 0,0,0,0,
                    1,0,0,0, 1,0,1,0, 1,0,0,1, 0,0,0,0, 0,0,0,1,
                    0,1,0,0, 0,1,0,1, 0,1,1,1, 0,0,0,0, 0,0,1,0,
                    0,0,1,0, 1,0,0,0, 1,1,0,0, 0,0,0,0, 0,1,0,0,
                    0,0,0,1, 0,1,0,0, 1,0,0,0, 0,0,0,0, 1,0,0,0};
    memcpy(decMat[0], a, 160 * sizeof(int));   

    // idx = 1, Dk2 lost
    int b[160] = {  1,0,0,0, 1,0,0,0, 1,0,0,0, 1,0,0,0, 0,0,0,0,
                    0,1,0,0, 0,1,0,0, 0,1,0,0, 0,1,0,0, 0,0,0,0,
                    0,0,1,0, 1,0,0,0, 1,1,0,0, 0,0,0,0, 0,1,0,0,
                    0,0,0,1, 0,1,0,0, 1,0,0,0, 0,0,0,0, 1,0,0,0,
                    0,0,0,0, 0,0,1,0, 0,0,0,1, 1,0,0,0, 0,0,0,1,
                    0,0,0,0, 0,0,0,1, 0,0,1,1, 0,1,0,0, 0,0,1,0,
                    0,0,1,0, 0,0,1,0, 0,0,1,0, 0,0,1,0, 0,0,0,0,
                    0,0,0,1, 0,0,0,1, 0,0,0,1, 0,0,0,1, 0,0,0,0};     
    memcpy(decMat[1], b, 160 * sizeof(int));  

    // idx = 2, Dk1 lost 
    int c[160] = {  1,0,0,0, 1,0,0,0, 1,0,0,0, 1,0,0,0, 0,0,0,0,
                    0,0,0,1, 0,1,0,0, 1,0,0,0, 0,0,0,0, 1,0,0,0,
                    1,0,1,0, 0,0,0,0, 0,1,0,0, 1,0,0,0, 0,1,0,0,
                    0,1,0,0, 0,1,0,0, 0,1,0,0, 0,1,0,0, 0,0,0,0,
                    0,0,1,0, 0,0,1,0, 0,0,1,0, 0,0,1,0, 0,0,0,0,
                    0,0,0,1, 0,0,0,0, 0,0,1,0, 0,1,0,1, 0,0,1,0,
                    0,0,0,0, 0,0,1,0, 0,0,0,1, 1,0,0,0, 0,0,0,1,
                    0,0,0,1, 0,0,0,1, 0,0,0,1, 0,0,0,1, 0,0,0,0};
    memcpy(decMat[2], c, 160 * sizeof(int));

    // idx = 3, Dk0 lost
    int d[160] = {  1,0,0,0, 1,0,0,0, 1,0,0,0, 1,0,0,0, 0,0,0,0,
                    1,0,0,1, 1,1,0,0, 0,0,0,0, 1,0,0,0, 1,0,0,0,
                    0,1,0,0, 0,1,0,0, 0,1,0,0, 0,1,0,0, 0,0,0,0,
                    1,0,1,0, 0,0,0,0, 0,1,0,0, 1,0,0,0, 0,1,0,0,
                    0,0,1,0, 0,0,1,0, 0,0,1,0, 0,0,1,0, 0,0,0,0,
                    0,0,1,1, 0,0,1,0, 0,0,0,0, 0,1,1,1, 0,0,1,0,
                    0,0,0,1, 0,0,0,1, 0,0,0,1, 0,0,0,1, 0,0,0,0,
                    0,0,0,0, 0,0,1,0, 0,0,0,1, 1,0,0,0, 0,0,0,1};
    memcpy(decMat[3], d, 160 * sizeof(int));

    // idx = 4, parity H lost
    int e[160] = {  0,0,0,0, 1,0,0,0, 0,0,1,0, 0,0,0,1, 0,0,0,1,
                    0,0,0,0, 0,1,0,0, 0,0,0,1, 0,0,1,1, 0,0,1,0,
                    0,0,0,0, 0,0,1,0, 1,0,1,0, 1,1,1,0, 0,1,0,0,
                    0,0,0,0, 0,0,0,1, 0,1,0,1, 1,0,0,1, 1,0,0,0,
                    1,0,0,0, 1,0,0,0, 1,0,0,0, 1,0,0,0, 0,0,0,0,
                    0,1,0,0, 0,1,0,0, 0,1,0,0, 0,1,0,0, 0,0,0,0,
                    0,0,1,0, 0,0,1,0, 0,0,1,0, 0,0,1,0, 0,0,0,0,
                    0,0,0,1, 0,0,0,1, 0,0,0,1, 0,0,0,1, 0,0,0,0};
    memcpy(decMat[4], e, 160 * sizeof(int));

    // idx = 5, parity B lost
    int f[160] = {  0,0,0,0, 1,0,0,0, 0,0,1,0, 0,0,0,1, 0,0,0,1,
                    0,0,0,0, 0,1,0,0, 0,0,0,1, 0,0,1,1, 0,0,1,0,
                    0,0,0,0, 0,0,1,0, 1,0,1,0, 1,1,1,0, 0,1,0,0,
                    0,0,0,0, 0,0,0,1, 0,1,0,1, 1,0,0,1, 1,0,0,0,
                    0,0,0,1, 1,0,0,0, 1,0,0,0, 1,0,0,0, 0,0,0,0,
                    0,0,1,0, 0,1,0,0, 0,1,0,0, 0,1,0,0, 0,0,0,0,
                    0,1,0,0, 0,0,1,0, 0,0,1,0, 0,0,1,0, 0,0,0,0,
                    1,0,0,0, 0,0,0,1, 0,0,0,1, 0,0,0,1, 0,0,0,0};
    memcpy(decMat[5], f, 160 * sizeof(int));
}

